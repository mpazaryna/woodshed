import asyncio
import time

import pytest
from hypothesis import given
from hypothesis import strategies as st
from PIL import Image

from aiforge.config import config
# from paz.images.processors import load_image
from aiforge.images.load import load_image


@pytest.mark.asyncio
async def test_load_image():
    # Arrange
    test_image_name = config.tmp_dir / "test.png"

    # Act
    result = await load_image(test_image_name)

    # Assert
    assert isinstance(result, Image.Image)
    assert result.format in ["PNG", "JPEG", "JPG"]  # Check if it's a valid image format
    assert (
        result.size[0] > 0 and result.size[1] > 0
    )  # Check if the image has valid dimensions


@pytest.mark.asyncio
async def test_load_image_async():
    # Arrange
    test_image_name = "test.png"

    # Create a wrapper function that adds a delay before calling load_image
    async def delayed_load_image(delay, name):
        await asyncio.sleep(delay)
        return await load_image(name)

    # Act
    start_time = time.time()

    # Create three tasks: two with delays and one without
    tasks = [
        delayed_load_image(0.1, test_image_name),
        delayed_load_image(0.2, test_image_name),
        load_image(test_image_name),
    ]

    # Run the tasks concurrently
    results = await asyncio.gather(*tasks)

    end_time = time.time()

    # Assert
    total_time = end_time - start_time

    # Check that all results are valid images
    for result in results:
        assert isinstance(result, Image.Image)
        assert result.format in ["PNG", "JPEG", "JPG"]
        assert result.size[0] > 0 and result.size[1] > 0

    # Check that the total time is less than the sum of individual delays
    # This indicates that the operations were indeed running concurrently
    assert (
        total_time < 0.3
    ), f"Expected execution time less than 0.3 seconds, but got {total_time}"


@pytest.mark.asyncio
@given(num_concurrent_loads=st.integers(min_value=2, max_value=10))
async def test_load_image_concurrent(num_concurrent_loads: int):
    """
    Test the concurrent behavior of the load_image function using Hypothesis.

    This approach should provide a more reliable test of the concurrent behavior.
    If the operations are truly concurrent, the total execution time should be
    significantly less than what sequential execution would take.

    This test verifies that:
    1. Multiple calls to load_image can be executed concurrently on the same file.
    2. Each call to load_image produces a valid Image object.
    3. The function can handle multiple concurrent requests efficiently.

    Args:
        num_concurrent_loads (int): Number of concurrent load operations to perform,
                                    generated by Hypothesis.

    Raises:
        AssertionError: If any of the assertions fail, indicating issues with
                        the concurrent behavior or image loading.
    """
    # Arrange
    test_image_name = "test.png"

    async def load_and_check() -> bool:
        await asyncio.sleep(0.1)  # Small delay to make concurrency more apparent
        image = await load_image(test_image_name)
        return (
            isinstance(image, Image.Image)
            and image.format in ["PNG", "JPEG", "JPG"]
            and image.size[0] > 0
            and image.size[1] > 0
        )

    # Act
    start_time = asyncio.get_event_loop().time()
    results = await asyncio.gather(
        *[load_and_check() for _ in range(num_concurrent_loads)]
    )
    end_time = asyncio.get_event_loop().time()

    # Assert
    assert all(results), f"Not all images were loaded successfully. Results: {results}"
    assert (
        len(results) == num_concurrent_loads
    ), "Number of results doesn't match number of requested loads"

    # Check if the total time is less than what sequential execution would take
    total_time = end_time - start_time
    sequential_time = 0.1 * num_concurrent_loads
    assert total_time < sequential_time, (
        f"Execution time ({total_time: .2f}s) suggests operations might not be concurrent. "
        f"Sequential time would be approximately {sequential_time: .2f}s."
    )
